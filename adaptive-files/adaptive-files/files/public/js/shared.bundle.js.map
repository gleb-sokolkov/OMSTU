{"version":3,"file":"js/shared.bundle.js","mappings":";;;;;;;;;;;;;;AAAe;AACf;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1Ce;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtBuC;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,8DAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzCgC;AACI;AACM;AAC1C;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAQ,CAAC,wDAAW;AAC9D;AACA;AACA;AACA;AACA,iCAAiC,+DAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,EAAE,MAAM,EAAE,MAAM,GAAG;AACrE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,EAAE,MAAM,EAAE,MAAM,GAAG;AAClF;AACA;AACA,aAAa;AACb;AACA;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;UCrEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNoD;AAClB;AACU;AACF;AAC1C;AACA,eAAe,gEAAgB,iCAAiC,mDAAI;AACpE,mBAAmB,gEAAgB,sCAAsC,uDAAQ,OAAO,gEAAgB;AACxG,iBAAiB,gEAAgB,sCAAsC,wDAAM,Q","sources":["webpack://files/./client/js/lib/closures.js","webpack://files/./client/js/lib/dom.js","webpack://files/./client/js/menu/index.js","webpack://files/./client/js/slider/index.js","webpack://files/./node_modules/debounce/index.js","webpack://files/webpack/bootstrap","webpack://files/webpack/runtime/compat get default export","webpack://files/webpack/runtime/define property getters","webpack://files/webpack/runtime/hasOwnProperty shorthand","webpack://files/webpack/runtime/make namespace object","webpack://files/./client/index.js"],"sourcesContent":["export default class CLOSURES {\r\n\r\n    /**\r\n     * A Timer function represents callback execution at each iteration with some delay and exit function\r\n     * @param {Function} func callback function \r\n     * @param {Number} delay interval delay\r\n     * @param {Function} exit_func checks condition of exit at each iteration. If it returns false, the timer moves to a new iteration, otherwise the timer stops execution  \r\n     * @returns {Function} closure, that can be executed later  \r\n     */\r\n    static wrapTimeout = (func, delay, exit_func, f = () => {\r\n        if(exit_func?.()) {\r\n            return;\r\n        }\r\n        func();\r\n        setTimeout(f, delay);\r\n    }) => () => setTimeout(f, delay);\r\n\r\n\r\n    /**\r\n     * A Sleep function creates a promise-wrapper of the setTimeout function. It must be called with await operator. \r\n     */\r\n    static sleep(delay) {\r\n        return new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n    \r\n    static delayedFunc = (callback, delay, iterationEnds = true) => async (...params) => {\r\n        if(iterationEnds) {\r\n            iterationEnds = false;\r\n            await this.sleep(delay);\r\n            iterationEnds = true;\r\n            callback(...params);\r\n        }\r\n    };\r\n\r\n    static awaitFunc = (callback, delay, iterationEnds = true) => async (...params) => {\r\n        if(iterationEnds) {\r\n            iterationEnds = false;\r\n            callback(...params);\r\n            await this.sleep(delay);\r\n            iterationEnds = true;\r\n        }\r\n    };\r\n}\r\n","export default class DOMFunctions {\r\n\r\n    static SM_BREAKPOINT = 600;\r\n\r\n    static nextNeighbor(node) {\r\n        let neighbor = node.nextSibling;\r\n        while(neighbor && neighbor.nodeType !== 1) {\r\n            neighbor = neighbor.nextSibling;\r\n        }\r\n        return neighbor;\r\n    }\r\n    \r\n    /**\r\n     * Finds elements in DOM, which matches some query string, and converts a result to Array  \r\n     * @param {String} queryStr query string using to search elements, which matches this string \r\n     * @returns {Array.<Element>} Array of founded Elements\r\n     */\r\n    static findElements = (queryStr) => Array.prototype.slice.call(document.querySelectorAll(queryStr));\r\n    \r\n    static SM(a, b) {\r\n        document.documentElement.clientWidth <= DOMFunctions.SM_BREAKPOINT ? a() : b();\r\n    }\r\n}","import CLOSURES from \"../lib/closures\";\r\n\r\nexport class Menu {\r\n    \r\n    static className = \"anchor\";\r\n\r\n    constructor(root) {\r\n        this.root = root;\r\n        this.startOffset = this.root.getBoundingClientRect().top + document.documentElement.scrollTop;\r\n        if(document.documentElement.clientWidth > 600) {\r\n            window.addEventListener('scroll', CLOSURES.delayedFunc(this.collapse.bind(this), 500));\r\n        }\r\n    }\r\n\r\n    collapse() {\r\n        const offset = this.startOffset + this.root.offsetHeight;\r\n        if(window.scrollY - offset >= 0) {\r\n            this.root.classList.add(Menu.className);\r\n        }    \r\n        else {\r\n            this.root.classList.remove(Menu.className);\r\n        }\r\n    }\r\n}\r\n\r\nexport class Expander {\r\n    static expand = \"expand\";\r\n    static overflowHidden = \"overflow-hidden\";\r\n\r\n    constructor(toggler, expandable) {\r\n        this.expandable = expandable;\r\n        this.toggler = toggler;\r\n\r\n        this.toggler.onclick = this.switchState.bind(this);\r\n    }\r\n\r\n    switchState() {\r\n        this.expandable.classList.toggle(Expander.expand);\r\n        this.toggler.classList.toggle(Expander.expand);\r\n        document.documentElement.classList.toggle(Expander.overflowHidden);\r\n    }\r\n}","import DOM from \"../lib/dom.js\";\r\nimport { debounce } from \"debounce\";\r\nimport CLOSURES from \"../lib/closures.js\";\r\n\r\nexport default class Slider {\r\n\r\n    static SLIDE_DELAY = 10000;\r\n    static RESIZE_DELAY = 500;\r\n\r\n    constructor(root, delay) {\r\n\r\n        this.root = root;\r\n        this.delay = delay ?? Slider.SLIDE_DELAY;\r\n        this.items = Array.prototype.slice.call(root.querySelectorAll(\".slider-item\"));\r\n        this.currentItem = 0;\r\n\r\n        this.bindScrollButtons();\r\n            \r\n        window.addEventListener(\"resize\", debounce(DOM.SM.bind(this, \r\n            () => (this.currentPosition = this.halfRoundPosition).call(this), \r\n            () => (this.currentPosition = this.roundPosition).call(this)), Slider.RESIZE_DELAY));\r\n        window.dispatchEvent(new Event(\"resize\"));\r\n\r\n        this.activeItemDelayed = CLOSURES.awaitFunc(this.changeActiveItem.bind(this), 500);\r\n    }\r\n\r\n    changeActiveItem(index) {\r\n        this.restartInterval();\r\n        if (this.currentItem === index) return;\r\n        this.currentItem = index;\r\n        this.currentPosition();\r\n    }\r\n\r\n    nextActiveItem() {\r\n        this.activeItemDelayed((this.currentItem + 1) % this.items.length);\r\n    }\r\n\r\n    previousActiveItem() {\r\n        this.activeItemDelayed((this.currentItem - 1 + this.items.length) % this.items.length);\r\n    }\r\n\r\n    startInterval() {\r\n        this.interval = setTimeout(this.nextActiveItem.bind(this), this.delay);\r\n    }\r\n\r\n    restartInterval() {\r\n        this.stopInterval();\r\n        this.startInterval();\r\n    }\r\n\r\n    stopInterval() {\r\n        clearTimeout(this.interval);\r\n    }\r\n\r\n    createSwitchButtons() {\r\n        this.buttonContainer = this.root.querySelector('.slider-buttons-container');\r\n\r\n        this.buttons = this.items.map((item, index) => {\r\n            const button = document.createElement('button');\r\n            button.className = \"btn slider-button\";\r\n            button.onclick = this.changeActiveItem.bind(this, index);\r\n            this.buttonContainer.appendChild(button);\r\n            return button;\r\n        });\r\n    }\r\n\r\n    bindScrollButtons() {\r\n        this.nextButton = this.root.querySelector(\"[data-scroll='next']\");\r\n        this.nextButton.onclick = this.nextActiveItem.bind(this);\r\n\r\n        this.previousButton = this.root.querySelector(\"[data-scroll='previous']\");\r\n        this.previousButton.onclick = this.previousActiveItem.bind(this);\r\n    }\r\n\r\n    roundPosition() {\r\n\r\n        this.root.classList.toggle(\"half-round\", false);\r\n\r\n        const step = Math.PI * 2.0 / this.items.length;\r\n        const halfWidth = this.root.clientWidth * 0.5;\r\n        const halfHeight = this.root.clientHeight * 0.5;\r\n        this.items.forEach((item, index) => {\r\n            const offsetX = halfWidth - item.offsetWidth * 0.5;\r\n            const offsetY = halfHeight - item.offsetHeight * 0.5;\r\n            const indexWithOffset = (index + this.currentItem) % this.items.length;\r\n            let x = -Math.sin(indexWithOffset * step) * offsetX + offsetX;\r\n            let y = offsetY;\r\n            let z = -Math.cos(indexWithOffset * step) * offsetX + offsetX;\r\n\r\n            item.style.transform = `translate3d(${x}px, ${y}px, ${-z}px)`;\r\n        });\r\n    }\r\n\r\n    halfRoundPosition() {\r\n\r\n        this.root.classList.toggle(\"half-round\", true);\r\n\r\n        const width = this.root.clientWidth;\r\n        const halfWidth = width * 0.5;\r\n        const height = this.root.clientHeight;\r\n        const halfHeight = height * 0.5;\r\n        const fullWidth = this.items.reduce((s, t) => s + t.offsetWidth, 0);\r\n        const halfFullWidth = fullWidth * 0.5;\r\n        this.items\r\n            .map((t, i) => (i + this.currentItem) % this.items.length)\r\n            .reduce((sum, i) => {\r\n                const offsetX = halfWidth - this.items[this.currentItem].offsetWidth * 0.5;\r\n                const itemWidth = this.items[i].offsetWidth;\r\n                const offsetY = halfHeight - this.items[i].offsetHeight * 0.5;\r\n                let x = (sum + halfFullWidth) % fullWidth - halfFullWidth + offsetX;\r\n                let y = offsetY;\r\n                let z = 0;\r\n\r\n                this.items[i].classList.toggle(\"without-transition\", false);\r\n                if(x <= -itemWidth || x >= width) {\r\n                    this.items[i].classList.toggle(\"without-transition\", true); \r\n                }\r\n\r\n                this.items[i].style.transform = `translate3d(${x}px, ${y}px, ${-z}px)`;\r\n                \r\n                return sum + this.items[i].offsetWidth;\r\n            }, 0);\r\n    }\r\n}","/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\nfunction debounce(func, wait, immediate){\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  };\n\n  var debounced = function(){\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  \n  debounced.flush = function() {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n      \n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\n// Adds compatibility for ES modules\ndebounce.debounce = debounce;\n\nmodule.exports = debounce;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Menu, Expander } from './js/menu/index.js';\r\nimport DOM from './js/lib/dom.js';\r\nimport CLOSURES from './js/lib/closures.js';\r\nimport Slider from './js/slider/index.js';\r\n\r\nlet menuList = DOM.findElements(\".header-menu\").map(item => new Menu(item));\r\nlet expanderList = DOM.findElements(\".expander-wrapper\").map(item => new Expander(item, DOM.nextNeighbor(item)));\r\nlet sliderList = DOM.findElements(\".slider-container\").map(item => new Slider(item));"],"names":[],"sourceRoot":""}